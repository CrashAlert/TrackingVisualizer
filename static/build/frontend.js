/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; };\n\nvar t = _interopRequire(__webpack_require__(1));\n\nconsole.log(t.map([1, 2, 3], function (x) {\n  return x + 1;\n}));\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdGF0aWMvanMvbWFpbi5qcz82ZjIxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7SUFBTyxDQUFDLHVDQUFNLENBQWdCOztBQUU5QixPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLFdBQUM7U0FBSSxDQUFDLEdBQUcsQ0FBQztDQUFBLENBQUMsQ0FBQyIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHQgZnJvbSAndHJhbnNkdWNlcnMuanMnO1xuXG5jb25zb2xlLmxvZyh0Lm1hcChbMSwgMiwgM10sIHggPT4geCArIDEpKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3RhdGljL2pzL21haW4uanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 1 */
/***/ function(module, exports) {

	eval("\n// basic protocol helpers\n\nvar symbolExists = typeof Symbol !== 'undefined';\n\nvar protocols = {\n  iterator: symbolExists ? Symbol.iterator : '@@iterator',\n  transformer: symbolExists ? Symbol('transformer') : '@@transformer'\n};\n\nfunction throwProtocolError(name, coll) {\n  throw new Error(\"don't know how to \" + name + \" collection: \" +\n                  coll);\n}\n\nfunction fulfillsProtocol(obj, name) {\n  if(name === 'iterator') {\n    // Accept ill-formed iterators that don't conform to the\n    // protocol by accepting just next()\n    return obj[protocols.iterator] || obj.next;\n  }\n\n  return obj[protocols[name]];\n}\n\nfunction getProtocolProperty(obj, name) {\n  return obj[protocols[name]];\n}\n\nfunction iterator(coll) {\n  var iter = getProtocolProperty(coll, 'iterator');\n  if(iter) {\n    return iter.call(coll);\n  }\n  else if(coll.next) {\n    // Basic duck typing to accept an ill-formed iterator that doesn't\n    // conform to the iterator protocol (all iterators should have the\n    // @@iterator method and return themselves, but some engines don't\n    // have that on generators like older v8)\n    return coll;\n  }\n  else if(isArray(coll)) {\n    return new ArrayIterator(coll);\n  }\n  else if(isObject(coll)) {\n    return new ObjectIterator(coll);\n  }\n}\n\nfunction ArrayIterator(arr) {\n  this.arr = arr;\n  this.index = 0;\n}\n\nArrayIterator.prototype.next = function() {\n  if(this.index < this.arr.length) {\n    return {\n      value: this.arr[this.index++],\n      done: false\n    };\n  }\n  return {\n    done: true\n  }\n};\n\nfunction ObjectIterator(obj) {\n  this.obj = obj;\n  this.keys = Object.keys(obj);\n  this.index = 0;\n}\n\nObjectIterator.prototype.next = function() {\n  if(this.index < this.keys.length) {\n    var k = this.keys[this.index++];\n    return {\n      value: [k, this.obj[k]],\n      done: false\n    };\n  }\n  return {\n    done: true\n  }\n};\n\n// helpers\n\nvar toString = Object.prototype.toString;\nvar isArray = typeof Array.isArray === 'function' ? Array.isArray : function(obj) {\n  return toString.call(obj) == '[object Array]';\n};\n\nfunction isFunction(x) {\n  return typeof x === 'function';\n}\n\nfunction isObject(x) {\n  return x instanceof Object &&\n    Object.getPrototypeOf(x) === Object.getPrototypeOf({});\n}\n\nfunction isNumber(x) {\n  return typeof x === 'number';\n}\n\nfunction Reduced(value) {\n  this.__transducers_reduced__ = true;\n  this.value = value;\n}\n\nfunction isReduced(x) {\n  return (x instanceof Reduced) || (x && x.__transducers_reduced__);\n}\n\nfunction deref(x) {\n  return x.value;\n}\n\n/**\n * This is for transforms that may call their nested transforms before\n * Reduced-wrapping the result (e.g. \"take\"), to avoid nested Reduced.\n */\nfunction ensureReduced(val) {\n  if(isReduced(val)) {\n    return val;\n  } else {\n    return new Reduced(val);\n  }\n}\n\n/**\n * This is for tranforms that call their nested transforms when\n * performing completion (like \"partition\"), to avoid signaling\n * termination after already completing.\n */\nfunction ensureUnreduced(v) {\n  if(isReduced(v)) {\n    return deref(v);\n  } else {\n    return v;\n  }\n}\n\nfunction reduce(coll, xform, init) {\n  if(isArray(coll)) {\n    var result = init;\n    var index = -1;\n    var len = coll.length;\n    while(++index < len) {\n      result = xform.step(result, coll[index]);\n      if(isReduced(result)) {\n        result = deref(result);\n        break;\n      }\n    }\n    return xform.result(result);\n  }\n  else if(isObject(coll) || fulfillsProtocol(coll, 'iterator')) {\n    var result = init;\n    var iter = iterator(coll);\n    var val = iter.next();\n    while(!val.done) {\n      result = xform.step(result, val.value);\n      if(isReduced(result)) {\n        result = deref(result);\n        break;\n      }\n      val = iter.next();\n    }\n    return xform.result(result);\n  }\n  throwProtocolError('iterate', coll);\n}\n\nfunction transduce(coll, xform, reducer, init) {\n  xform = xform(reducer);\n  if(init === undefined) {\n    init = xform.init();\n  }\n  return reduce(coll, xform, init);\n}\n\nfunction compose() {\n  var funcs = Array.prototype.slice.call(arguments);\n  return function(r) {\n    var value = r;\n    for(var i=funcs.length-1; i>=0; i--) {\n      value = funcs[i](value);\n    }\n    return value;\n  }\n}\n\n// transformations\n\nfunction transformer(f) {\n  return {\n    init: function() {\n      throw new Error('init value unavailable');\n    },\n    result: function(v) {\n      return v;\n    },\n    step: f\n  };\n}\n\nfunction bound(f, ctx, count) {\n  count = count != null ? count : 1;\n\n  if(!ctx) {\n    return f;\n  }\n  else {\n    switch(count) {\n    case 1:\n      return function(x) {\n        return f.call(ctx, x);\n      }\n    case 2:\n      return function(x, y) {\n        return f.call(ctx, x, y);\n      }\n    default:\n      return f.bind(ctx);\n    }\n  }\n}\n\nfunction arrayMap(arr, f, ctx) {\n  var index = -1;\n  var length = arr.length;\n  var result = Array(length);\n  f = bound(f, ctx, 2);\n\n  while (++index < length) {\n    result[index] = f(arr[index], index);\n  }\n  return result;\n}\n\nfunction arrayFilter(arr, f, ctx) {\n  var len = arr.length;\n  var result = [];\n  f = bound(f, ctx, 2);\n\n  for(var i=0; i<len; i++) {\n    if(f(arr[i], i)) {\n      result.push(arr[i]);\n    }\n  }\n  return result;\n}\n\nfunction Map(f, xform) {\n  this.xform = xform;\n  this.f = f;\n}\n\nMap.prototype.init = function() {\n  return this.xform.init();\n};\n\nMap.prototype.result = function(v) {\n  return this.xform.result(v);\n};\n\nMap.prototype.step = function(res, input) {\n  return this.xform.step(res, this.f(input));\n};\n\nfunction map(coll, f, ctx) {\n  if(isFunction(coll)) { ctx = f; f = coll; coll = null; }\n  f = bound(f, ctx);\n\n  if(coll) {\n    if(isArray(coll)) {\n      return arrayMap(coll, f, ctx);\n    }\n    return seq(coll, map(f));\n  }\n\n  return function(xform) {\n    return new Map(f, xform);\n  }\n}\n\nfunction Filter(f, xform) {\n  this.xform = xform;\n  this.f = f;\n}\n\nFilter.prototype.init = function() {\n  return this.xform.init();\n};\n\nFilter.prototype.result = function(v) {\n  return this.xform.result(v);\n};\n\nFilter.prototype.step = function(res, input) {\n  if(this.f(input)) {\n    return this.xform.step(res, input);\n  }\n  return res;\n};\n\nfunction filter(coll, f, ctx) {\n  if(isFunction(coll)) { ctx = f; f = coll; coll = null; }\n  f = bound(f, ctx);\n\n  if(coll) {\n    if(isArray(coll)) {\n      return arrayFilter(coll, f, ctx);\n    }\n    return seq(coll, filter(f));\n  }\n\n  return function(xform) {\n    return new Filter(f, xform);\n  };\n}\n\nfunction remove(coll, f, ctx) {\n  if(isFunction(coll)) { ctx = f; f = coll; coll = null; }\n  f = bound(f, ctx);\n  return filter(coll, function(x) { return !f(x); });\n}\n\nfunction keep(coll) {\n  return filter(coll, function(x) { return x != null });\n}\n\nfunction Dedupe(xform) {\n  this.xform = xform;\n  this.last = undefined;\n}\n\nDedupe.prototype.init = function() {\n  return this.xform.init();\n};\n\nDedupe.prototype.result = function(v) {\n  return this.xform.result(v);\n};\n\nDedupe.prototype.step = function(result, input) {\n  if(input !== this.last) {\n    this.last = input;\n    return this.xform.step(result, input);\n  }\n  return result;\n};\n\nfunction dedupe(coll) {\n  if(coll) {\n    return seq(coll, dedupe());\n  }\n\n  return function(xform) {\n    return new Dedupe(xform);\n  }\n}\n\nfunction TakeWhile(f, xform) {\n  this.xform = xform;\n  this.f = f;\n}\n\nTakeWhile.prototype.init = function() {\n  return this.xform.init();\n};\n\nTakeWhile.prototype.result = function(v) {\n  return this.xform.result(v);\n};\n\nTakeWhile.prototype.step = function(result, input) {\n  if(this.f(input)) {\n    return this.xform.step(result, input);\n  }\n  return new Reduced(result);\n};\n\nfunction takeWhile(coll, f, ctx) {\n  if(isFunction(coll)) { ctx = f; f = coll; coll = null; }\n  f = bound(f, ctx);\n\n  if(coll) {\n    return seq(coll, takeWhile(f));\n  }\n\n  return function(xform) {\n    return new TakeWhile(f, xform);\n  }\n}\n\nfunction Take(n, xform) {\n  this.n = n;\n  this.i = 0;\n  this.xform = xform;\n}\n\nTake.prototype.init = function() {\n  return this.xform.init();\n};\n\nTake.prototype.result = function(v) {\n  return this.xform.result(v);\n};\n\nTake.prototype.step = function(result, input) {\n  if (this.i < this.n) {\n    result = this.xform.step(result, input);\n    if(this.i + 1 >= this.n) {\n      // Finish reducing on the same step as the final value. TODO:\n      // double-check that this doesn't break any semantics\n      result = ensureReduced(result);\n    }\n  }\n  this.i++;\n  return result;\n};\n\nfunction take(coll, n) {\n  if(isNumber(coll)) { n = coll; coll = null }\n\n  if(coll) {\n    return seq(coll, take(n));\n  }\n\n  return function(xform) {\n    return new Take(n, xform);\n  }\n}\n\nfunction Drop(n, xform) {\n  this.n = n;\n  this.i = 0;\n  this.xform = xform;\n}\n\nDrop.prototype.init = function() {\n  return this.xform.init();\n};\n\nDrop.prototype.result = function(v) {\n  return this.xform.result(v);\n};\n\nDrop.prototype.step = function(result, input) {\n  if(this.i++ < this.n) {\n    return result;\n  }\n  return this.xform.step(result, input);\n};\n\nfunction drop(coll, n) {\n  if(isNumber(coll)) { n = coll; coll = null }\n\n  if(coll) {\n    return seq(coll, drop(n));\n  }\n\n  return function(xform) {\n    return new Drop(n, xform);\n  }\n}\n\nfunction DropWhile(f, xform) {\n  this.xform = xform;\n  this.f = f;\n  this.dropping = true;\n}\n\nDropWhile.prototype.init = function() {\n  return this.xform.init();\n};\n\nDropWhile.prototype.result = function(v) {\n  return this.xform.result(v);\n};\n\nDropWhile.prototype.step = function(result, input) {\n  if(this.dropping) {\n    if(this.f(input)) {\n      return result;\n    }\n    else {\n      this.dropping = false;\n    }\n  }\n  return this.xform.step(result, input);\n};\n\nfunction dropWhile(coll, f, ctx) {\n  if(isFunction(coll)) { ctx = f; f = coll; coll = null; }\n  f = bound(f, ctx);\n\n  if(coll) {\n    return seq(coll, dropWhile(f));\n  }\n\n  return function(xform) {\n    return new DropWhile(f, xform);\n  }\n}\n\nfunction Partition(n, xform) {\n  this.n = n;\n  this.i = 0;\n  this.xform = xform;\n  this.part = new Array(n);\n}\n\nPartition.prototype.init = function() {\n  return this.xform.init();\n};\n\nPartition.prototype.result = function(v) {\n  if (this.i > 0) {\n    return ensureUnreduced(this.xform.step(v, this.part.slice(0, this.i)));\n  }\n  return this.xform.result(v);\n};\n\nPartition.prototype.step = function(result, input) {\n  this.part[this.i] = input;\n  this.i += 1;\n  if (this.i === this.n) {\n    var out = this.part.slice(0, this.n);\n    this.part = new Array(this.n);\n    this.i = 0;\n    return this.xform.step(result, out);\n  }\n  return result;\n};\n\nfunction partition(coll, n) {\n  if (isNumber(coll)) {\n    n = coll; coll = null;\n  }\n\n  if (coll) {\n    return seq(coll, partition(n));\n  }\n\n  return function(xform) {\n    return new Partition(n, xform);\n  };\n}\n\nvar NOTHING = {};\n\nfunction PartitionBy(f, xform) {\n  // TODO: take an \"opts\" object that allows the user to specify\n  // equality\n  this.f = f;\n  this.xform = xform;\n  this.part = [];\n  this.last = NOTHING;\n}\n\nPartitionBy.prototype.init = function() {\n  return this.xform.init();\n};\n\nPartitionBy.prototype.result = function(v) {\n  var l = this.part.length;\n  if (l > 0) {\n    return ensureUnreduced(this.xform.step(v, this.part.slice(0, l)));\n  }\n  return this.xform.result(v);\n};\n\nPartitionBy.prototype.step = function(result, input) {\n  var current = this.f(input);\n  if (current === this.last || this.last === NOTHING) {\n    this.part.push(input);\n  } else {\n    result = this.xform.step(result, this.part);\n    this.part = [input];\n  }\n  this.last = current;\n  return result;\n};\n\nfunction partitionBy(coll, f, ctx) {\n  if (isFunction(coll)) { ctx = f; f = coll; coll = null; }\n  f = bound(f, ctx);\n\n  if (coll) {\n    return seq(coll, partitionBy(f));\n  }\n\n  return function(xform) {\n    return new PartitionBy(f, xform);\n  };\n}\n\n// pure transducers (cannot take collections)\n\nfunction Cat(xform) {\n  this.xform = xform;\n}\n\nCat.prototype.init = function() {\n  return this.xform.init();\n};\n\nCat.prototype.result = function(v) {\n  return this.xform.result(v);\n};\n\nCat.prototype.step = function(result, input) {\n  var xform = this.xform;\n  var newxform = {\n    init: function() {\n      return xform.init();\n    },\n    result: function(v) {\n      return v;\n    },\n    step: function(result, input) {\n      var val = xform.step(result, input);\n      return isReduced(val) ? deref(val) : val;\n    }\n  }\n\n  return reduce(input, newxform, result);\n};\n\nfunction cat(xform) {\n  return new Cat(xform);\n}\n\nfunction mapcat(f, ctx) {\n  f = bound(f, ctx);\n  return compose(map(f), cat);\n}\n\n// collection helpers\n\nfunction push(arr, x) {\n  arr.push(x);\n  return arr;\n}\n\nfunction merge(obj, x) {\n  if(isArray(x) && x.length === 2) {\n    obj[x[0]] = x[1];\n  }\n  else {\n    var keys = Object.keys(x);\n    var len = keys.length;\n    for(var i=0; i<len; i++) {\n      obj[keys[i]] = x[keys[i]];\n    }\n  }\n  return obj;\n}\n\nvar arrayReducer = {\n  init: function() {\n    return [];\n  },\n  result: function(v) {\n    return v;\n  },\n  step: push\n}\n\nvar objReducer = {\n  init: function() {\n    return {};\n  },\n  result: function(v) {\n    return v;\n  },\n  step: merge\n};\n\nfunction getReducer(coll) {\n  if(isArray(coll)) {\n    return arrayReducer;\n  }\n  else if(isObject(coll)) {\n    return objReducer;\n  }\n  else if(fulfillsProtocol(coll, 'transformer')) {\n    return getProtocolProperty(coll, 'transformer');\n  }\n  throwProtocolError('getReducer', coll);\n}\n\n// building new collections\n\nfunction toArray(coll, xform) {\n  if(!xform) {\n    return reduce(coll, arrayReducer, []);\n  }\n  return transduce(coll, xform, arrayReducer, []);\n}\n\nfunction toObj(coll, xform) {\n  if(!xform) {\n    return reduce(coll, objReducer, {});\n  }\n  return transduce(coll, xform, objReducer, {});\n}\n\nfunction toIter(coll, xform) {\n  if(!xform) {\n    return iterator(coll);\n  }\n  return new LazyTransformer(xform, coll);\n}\n\nfunction seq(coll, xform) {\n  if(isArray(coll)) {\n    return transduce(coll, xform, arrayReducer, []);\n  }\n  else if(isObject(coll)) {\n    return transduce(coll, xform, objReducer, {});\n  }\n  else if(fulfillsProtocol(coll, 'transformer')) {\n    var transformer = getProtocolProperty(coll, 'transformer');\n    return transduce(coll, xform, transformer, transformer.init());\n  }\n  else if(fulfillsProtocol(coll, 'iterator')) {\n    return new LazyTransformer(xform, coll);\n  }\n  throwProtocolError('sequence', coll);\n}\n\nfunction into(to, xform, from) {\n  if(isArray(to)) {\n    return transduce(from, xform, arrayReducer, to);\n  }\n  else if(isObject(to)) {\n    return transduce(from, xform, objReducer, to);\n  }\n  else if(fulfillsProtocol(to, 'transformer')) {\n    return transduce(from,\n                     xform,\n                     getProtocolProperty(to, 'transformer'),\n                     to);\n  }\n  throwProtocolError('into', to);\n}\n\n// laziness\n\nvar stepper = {\n  result: function(v) {\n    return isReduced(v) ? deref(v) : v;\n  },\n  step: function(lt, x) {\n    lt.items.push(x);\n    return lt.rest;\n  }\n}\n\nfunction Stepper(xform, iter) {\n  this.xform = xform(stepper);\n  this.iter = iter;\n}\n\nStepper.prototype.step = function(lt) {\n  var len = lt.items.length;\n  while(lt.items.length === len) {\n    var n = this.iter.next();\n    if(n.done || isReduced(n.value)) {\n      // finalize\n      this.xform.result(this);\n      break;\n    }\n\n    // step\n    this.xform.step(lt, n.value);\n  }\n}\n\nfunction LazyTransformer(xform, coll) {\n  this.iter = iterator(coll);\n  this.items = [];\n  this.stepper = new Stepper(xform, iterator(coll));\n}\n\nLazyTransformer.prototype[protocols.iterator] = function() {\n  return this;\n}\n\nLazyTransformer.prototype.next = function() {\n  this.step();\n\n  if(this.items.length) {\n    return {\n      value: this.items.pop(),\n      done: false\n    }\n  }\n  else {\n    return { done: true };\n  }\n};\n\nLazyTransformer.prototype.step = function() {\n  if(!this.items.length) {\n    this.stepper.step(this);\n  }\n}\n\n// util\n\nfunction range(n) {\n  var arr = new Array(n);\n  for(var i=0; i<arr.length; i++) {\n    arr[i] = i;\n  }\n  return arr;\n}\n\n\nmodule.exports = {\n  reduce: reduce,\n  transformer: transformer,\n  Reduced: Reduced,\n  iterator: iterator,\n  push: push,\n  merge: merge,\n  transduce: transduce,\n  seq: seq,\n  toArray: toArray,\n  toObj: toObj,\n  toIter: toIter,\n  into: into,\n  compose: compose,\n  map: map,\n  filter: filter,\n  remove: remove,\n  cat: cat,\n  mapcat: mapcat,\n  keep: keep,\n  dedupe: dedupe,\n  take: take,\n  takeWhile: takeWhile,\n  drop: drop,\n  dropWhile: dropWhile,\n  partition: partition,\n  partitionBy: partitionBy,\n  range: range,\n\n  protocols: protocols,\n  LazyTransformer: LazyTransformer\n};\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3RyYW5zZHVjZXJzLmpzL3RyYW5zZHVjZXJzLmpzP2IzNmMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsTUFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLFNBQVMsVUFBVSxhQUFhO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixTQUFTLFVBQVUsYUFBYTtBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsU0FBUyxVQUFVLGFBQWE7QUFDeEQ7QUFDQSxtQ0FBbUMsY0FBYyxFQUFFO0FBQ25EOztBQUVBO0FBQ0EsbUNBQW1DLG1CQUFtQjtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLFNBQVMsVUFBVSxhQUFhO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLFVBQVU7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLFVBQVU7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixTQUFTLFVBQVUsYUFBYTtBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsU0FBUyxVQUFVLGFBQWE7QUFDekQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsOENBQThDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8vIGJhc2ljIHByb3RvY29sIGhlbHBlcnNcblxudmFyIHN5bWJvbEV4aXN0cyA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnO1xuXG52YXIgcHJvdG9jb2xzID0ge1xuICBpdGVyYXRvcjogc3ltYm9sRXhpc3RzID8gU3ltYm9sLml0ZXJhdG9yIDogJ0BAaXRlcmF0b3InLFxuICB0cmFuc2Zvcm1lcjogc3ltYm9sRXhpc3RzID8gU3ltYm9sKCd0cmFuc2Zvcm1lcicpIDogJ0BAdHJhbnNmb3JtZXInXG59O1xuXG5mdW5jdGlvbiB0aHJvd1Byb3RvY29sRXJyb3IobmFtZSwgY29sbCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJkb24ndCBrbm93IGhvdyB0byBcIiArIG5hbWUgKyBcIiBjb2xsZWN0aW9uOiBcIiArXG4gICAgICAgICAgICAgICAgICBjb2xsKTtcbn1cblxuZnVuY3Rpb24gZnVsZmlsbHNQcm90b2NvbChvYmosIG5hbWUpIHtcbiAgaWYobmFtZSA9PT0gJ2l0ZXJhdG9yJykge1xuICAgIC8vIEFjY2VwdCBpbGwtZm9ybWVkIGl0ZXJhdG9ycyB0aGF0IGRvbid0IGNvbmZvcm0gdG8gdGhlXG4gICAgLy8gcHJvdG9jb2wgYnkgYWNjZXB0aW5nIGp1c3QgbmV4dCgpXG4gICAgcmV0dXJuIG9ialtwcm90b2NvbHMuaXRlcmF0b3JdIHx8IG9iai5uZXh0O1xuICB9XG5cbiAgcmV0dXJuIG9ialtwcm90b2NvbHNbbmFtZV1dO1xufVxuXG5mdW5jdGlvbiBnZXRQcm90b2NvbFByb3BlcnR5KG9iaiwgbmFtZSkge1xuICByZXR1cm4gb2JqW3Byb3RvY29sc1tuYW1lXV07XG59XG5cbmZ1bmN0aW9uIGl0ZXJhdG9yKGNvbGwpIHtcbiAgdmFyIGl0ZXIgPSBnZXRQcm90b2NvbFByb3BlcnR5KGNvbGwsICdpdGVyYXRvcicpO1xuICBpZihpdGVyKSB7XG4gICAgcmV0dXJuIGl0ZXIuY2FsbChjb2xsKTtcbiAgfVxuICBlbHNlIGlmKGNvbGwubmV4dCkge1xuICAgIC8vIEJhc2ljIGR1Y2sgdHlwaW5nIHRvIGFjY2VwdCBhbiBpbGwtZm9ybWVkIGl0ZXJhdG9yIHRoYXQgZG9lc24ndFxuICAgIC8vIGNvbmZvcm0gdG8gdGhlIGl0ZXJhdG9yIHByb3RvY29sIChhbGwgaXRlcmF0b3JzIHNob3VsZCBoYXZlIHRoZVxuICAgIC8vIEBAaXRlcmF0b3IgbWV0aG9kIGFuZCByZXR1cm4gdGhlbXNlbHZlcywgYnV0IHNvbWUgZW5naW5lcyBkb24ndFxuICAgIC8vIGhhdmUgdGhhdCBvbiBnZW5lcmF0b3JzIGxpa2Ugb2xkZXIgdjgpXG4gICAgcmV0dXJuIGNvbGw7XG4gIH1cbiAgZWxzZSBpZihpc0FycmF5KGNvbGwpKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheUl0ZXJhdG9yKGNvbGwpO1xuICB9XG4gIGVsc2UgaWYoaXNPYmplY3QoY29sbCkpIHtcbiAgICByZXR1cm4gbmV3IE9iamVjdEl0ZXJhdG9yKGNvbGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIEFycmF5SXRlcmF0b3IoYXJyKSB7XG4gIHRoaXMuYXJyID0gYXJyO1xuICB0aGlzLmluZGV4ID0gMDtcbn1cblxuQXJyYXlJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICBpZih0aGlzLmluZGV4IDwgdGhpcy5hcnIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiB0aGlzLmFyclt0aGlzLmluZGV4KytdLFxuICAgICAgZG9uZTogZmFsc2VcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgZG9uZTogdHJ1ZVxuICB9XG59O1xuXG5mdW5jdGlvbiBPYmplY3RJdGVyYXRvcihvYmopIHtcbiAgdGhpcy5vYmogPSBvYmo7XG4gIHRoaXMua2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIHRoaXMuaW5kZXggPSAwO1xufVxuXG5PYmplY3RJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICBpZih0aGlzLmluZGV4IDwgdGhpcy5rZXlzLmxlbmd0aCkge1xuICAgIHZhciBrID0gdGhpcy5rZXlzW3RoaXMuaW5kZXgrK107XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBbaywgdGhpcy5vYmpba11dLFxuICAgICAgZG9uZTogZmFsc2VcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgZG9uZTogdHJ1ZVxuICB9XG59O1xuXG4vLyBoZWxwZXJzXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgaXNBcnJheSA9IHR5cGVvZiBBcnJheS5pc0FycmF5ID09PSAnZnVuY3Rpb24nID8gQXJyYXkuaXNBcnJheSA6IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdCh4KSB7XG4gIHJldHVybiB4IGluc3RhbmNlb2YgT2JqZWN0ICYmXG4gICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKHgpID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoe30pO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIFJlZHVjZWQodmFsdWUpIHtcbiAgdGhpcy5fX3RyYW5zZHVjZXJzX3JlZHVjZWRfXyA9IHRydWU7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gaXNSZWR1Y2VkKHgpIHtcbiAgcmV0dXJuICh4IGluc3RhbmNlb2YgUmVkdWNlZCkgfHwgKHggJiYgeC5fX3RyYW5zZHVjZXJzX3JlZHVjZWRfXyk7XG59XG5cbmZ1bmN0aW9uIGRlcmVmKHgpIHtcbiAgcmV0dXJuIHgudmFsdWU7XG59XG5cbi8qKlxuICogVGhpcyBpcyBmb3IgdHJhbnNmb3JtcyB0aGF0IG1heSBjYWxsIHRoZWlyIG5lc3RlZCB0cmFuc2Zvcm1zIGJlZm9yZVxuICogUmVkdWNlZC13cmFwcGluZyB0aGUgcmVzdWx0IChlLmcuIFwidGFrZVwiKSwgdG8gYXZvaWQgbmVzdGVkIFJlZHVjZWQuXG4gKi9cbmZ1bmN0aW9uIGVuc3VyZVJlZHVjZWQodmFsKSB7XG4gIGlmKGlzUmVkdWNlZCh2YWwpKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IFJlZHVjZWQodmFsKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgZm9yIHRyYW5mb3JtcyB0aGF0IGNhbGwgdGhlaXIgbmVzdGVkIHRyYW5zZm9ybXMgd2hlblxuICogcGVyZm9ybWluZyBjb21wbGV0aW9uIChsaWtlIFwicGFydGl0aW9uXCIpLCB0byBhdm9pZCBzaWduYWxpbmdcbiAqIHRlcm1pbmF0aW9uIGFmdGVyIGFscmVhZHkgY29tcGxldGluZy5cbiAqL1xuZnVuY3Rpb24gZW5zdXJlVW5yZWR1Y2VkKHYpIHtcbiAgaWYoaXNSZWR1Y2VkKHYpKSB7XG4gICAgcmV0dXJuIGRlcmVmKHYpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlZHVjZShjb2xsLCB4Zm9ybSwgaW5pdCkge1xuICBpZihpc0FycmF5KGNvbGwpKSB7XG4gICAgdmFyIHJlc3VsdCA9IGluaXQ7XG4gICAgdmFyIGluZGV4ID0gLTE7XG4gICAgdmFyIGxlbiA9IGNvbGwubGVuZ3RoO1xuICAgIHdoaWxlKCsraW5kZXggPCBsZW4pIHtcbiAgICAgIHJlc3VsdCA9IHhmb3JtLnN0ZXAocmVzdWx0LCBjb2xsW2luZGV4XSk7XG4gICAgICBpZihpc1JlZHVjZWQocmVzdWx0KSkge1xuICAgICAgICByZXN1bHQgPSBkZXJlZihyZXN1bHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHhmb3JtLnJlc3VsdChyZXN1bHQpO1xuICB9XG4gIGVsc2UgaWYoaXNPYmplY3QoY29sbCkgfHwgZnVsZmlsbHNQcm90b2NvbChjb2xsLCAnaXRlcmF0b3InKSkge1xuICAgIHZhciByZXN1bHQgPSBpbml0O1xuICAgIHZhciBpdGVyID0gaXRlcmF0b3IoY29sbCk7XG4gICAgdmFyIHZhbCA9IGl0ZXIubmV4dCgpO1xuICAgIHdoaWxlKCF2YWwuZG9uZSkge1xuICAgICAgcmVzdWx0ID0geGZvcm0uc3RlcChyZXN1bHQsIHZhbC52YWx1ZSk7XG4gICAgICBpZihpc1JlZHVjZWQocmVzdWx0KSkge1xuICAgICAgICByZXN1bHQgPSBkZXJlZihyZXN1bHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHZhbCA9IGl0ZXIubmV4dCgpO1xuICAgIH1cbiAgICByZXR1cm4geGZvcm0ucmVzdWx0KHJlc3VsdCk7XG4gIH1cbiAgdGhyb3dQcm90b2NvbEVycm9yKCdpdGVyYXRlJywgY29sbCk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZHVjZShjb2xsLCB4Zm9ybSwgcmVkdWNlciwgaW5pdCkge1xuICB4Zm9ybSA9IHhmb3JtKHJlZHVjZXIpO1xuICBpZihpbml0ID09PSB1bmRlZmluZWQpIHtcbiAgICBpbml0ID0geGZvcm0uaW5pdCgpO1xuICB9XG4gIHJldHVybiByZWR1Y2UoY29sbCwgeGZvcm0sIGluaXQpO1xufVxuXG5mdW5jdGlvbiBjb21wb3NlKCkge1xuICB2YXIgZnVuY3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICByZXR1cm4gZnVuY3Rpb24ocikge1xuICAgIHZhciB2YWx1ZSA9IHI7XG4gICAgZm9yKHZhciBpPWZ1bmNzLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcbiAgICAgIHZhbHVlID0gZnVuY3NbaV0odmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLy8gdHJhbnNmb3JtYXRpb25zXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybWVyKGYpIHtcbiAgcmV0dXJuIHtcbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW5pdCB2YWx1ZSB1bmF2YWlsYWJsZScpO1xuICAgIH0sXG4gICAgcmVzdWx0OiBmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gdjtcbiAgICB9LFxuICAgIHN0ZXA6IGZcbiAgfTtcbn1cblxuZnVuY3Rpb24gYm91bmQoZiwgY3R4LCBjb3VudCkge1xuICBjb3VudCA9IGNvdW50ICE9IG51bGwgPyBjb3VudCA6IDE7XG5cbiAgaWYoIWN0eCkge1xuICAgIHJldHVybiBmO1xuICB9XG4gIGVsc2Uge1xuICAgIHN3aXRjaChjb3VudCkge1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBmLmNhbGwoY3R4LCB4KTtcbiAgICAgIH1cbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gZi5jYWxsKGN0eCwgeCwgeSk7XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmLmJpbmQoY3R4KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXJyYXlNYXAoYXJyLCBmLCBjdHgpIHtcbiAgdmFyIGluZGV4ID0gLTE7XG4gIHZhciBsZW5ndGggPSBhcnIubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgZiA9IGJvdW5kKGYsIGN0eCwgMik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gZihhcnJbaW5kZXhdLCBpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyLCBmLCBjdHgpIHtcbiAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZiA9IGJvdW5kKGYsIGN0eCwgMik7XG5cbiAgZm9yKHZhciBpPTA7IGk8bGVuOyBpKyspIHtcbiAgICBpZihmKGFycltpXSwgaSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIE1hcChmLCB4Zm9ybSkge1xuICB0aGlzLnhmb3JtID0geGZvcm07XG4gIHRoaXMuZiA9IGY7XG59XG5cbk1hcC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy54Zm9ybS5pbml0KCk7XG59O1xuXG5NYXAucHJvdG90eXBlLnJlc3VsdCA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIHRoaXMueGZvcm0ucmVzdWx0KHYpO1xufTtcblxuTWFwLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24ocmVzLCBpbnB1dCkge1xuICByZXR1cm4gdGhpcy54Zm9ybS5zdGVwKHJlcywgdGhpcy5mKGlucHV0KSk7XG59O1xuXG5mdW5jdGlvbiBtYXAoY29sbCwgZiwgY3R4KSB7XG4gIGlmKGlzRnVuY3Rpb24oY29sbCkpIHsgY3R4ID0gZjsgZiA9IGNvbGw7IGNvbGwgPSBudWxsOyB9XG4gIGYgPSBib3VuZChmLCBjdHgpO1xuXG4gIGlmKGNvbGwpIHtcbiAgICBpZihpc0FycmF5KGNvbGwpKSB7XG4gICAgICByZXR1cm4gYXJyYXlNYXAoY29sbCwgZiwgY3R4KTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcShjb2xsLCBtYXAoZikpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHhmb3JtKSB7XG4gICAgcmV0dXJuIG5ldyBNYXAoZiwgeGZvcm0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIEZpbHRlcihmLCB4Zm9ybSkge1xuICB0aGlzLnhmb3JtID0geGZvcm07XG4gIHRoaXMuZiA9IGY7XG59XG5cbkZpbHRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy54Zm9ybS5pbml0KCk7XG59O1xuXG5GaWx0ZXIucHJvdG90eXBlLnJlc3VsdCA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIHRoaXMueGZvcm0ucmVzdWx0KHYpO1xufTtcblxuRmlsdGVyLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24ocmVzLCBpbnB1dCkge1xuICBpZih0aGlzLmYoaW5wdXQpKSB7XG4gICAgcmV0dXJuIHRoaXMueGZvcm0uc3RlcChyZXMsIGlucHV0KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyKGNvbGwsIGYsIGN0eCkge1xuICBpZihpc0Z1bmN0aW9uKGNvbGwpKSB7IGN0eCA9IGY7IGYgPSBjb2xsOyBjb2xsID0gbnVsbDsgfVxuICBmID0gYm91bmQoZiwgY3R4KTtcblxuICBpZihjb2xsKSB7XG4gICAgaWYoaXNBcnJheShjb2xsKSkge1xuICAgICAgcmV0dXJuIGFycmF5RmlsdGVyKGNvbGwsIGYsIGN0eCk7XG4gICAgfVxuICAgIHJldHVybiBzZXEoY29sbCwgZmlsdGVyKGYpKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbih4Zm9ybSkge1xuICAgIHJldHVybiBuZXcgRmlsdGVyKGYsIHhmb3JtKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKGNvbGwsIGYsIGN0eCkge1xuICBpZihpc0Z1bmN0aW9uKGNvbGwpKSB7IGN0eCA9IGY7IGYgPSBjb2xsOyBjb2xsID0gbnVsbDsgfVxuICBmID0gYm91bmQoZiwgY3R4KTtcbiAgcmV0dXJuIGZpbHRlcihjb2xsLCBmdW5jdGlvbih4KSB7IHJldHVybiAhZih4KTsgfSk7XG59XG5cbmZ1bmN0aW9uIGtlZXAoY29sbCkge1xuICByZXR1cm4gZmlsdGVyKGNvbGwsIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHggIT0gbnVsbCB9KTtcbn1cblxuZnVuY3Rpb24gRGVkdXBlKHhmb3JtKSB7XG4gIHRoaXMueGZvcm0gPSB4Zm9ybTtcbiAgdGhpcy5sYXN0ID0gdW5kZWZpbmVkO1xufVxuXG5EZWR1cGUucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMueGZvcm0uaW5pdCgpO1xufTtcblxuRGVkdXBlLnByb3RvdHlwZS5yZXN1bHQgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiB0aGlzLnhmb3JtLnJlc3VsdCh2KTtcbn07XG5cbkRlZHVwZS5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uKHJlc3VsdCwgaW5wdXQpIHtcbiAgaWYoaW5wdXQgIT09IHRoaXMubGFzdCkge1xuICAgIHRoaXMubGFzdCA9IGlucHV0O1xuICAgIHJldHVybiB0aGlzLnhmb3JtLnN0ZXAocmVzdWx0LCBpbnB1dCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmZ1bmN0aW9uIGRlZHVwZShjb2xsKSB7XG4gIGlmKGNvbGwpIHtcbiAgICByZXR1cm4gc2VxKGNvbGwsIGRlZHVwZSgpKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbih4Zm9ybSkge1xuICAgIHJldHVybiBuZXcgRGVkdXBlKHhmb3JtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUYWtlV2hpbGUoZiwgeGZvcm0pIHtcbiAgdGhpcy54Zm9ybSA9IHhmb3JtO1xuICB0aGlzLmYgPSBmO1xufVxuXG5UYWtlV2hpbGUucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMueGZvcm0uaW5pdCgpO1xufTtcblxuVGFrZVdoaWxlLnByb3RvdHlwZS5yZXN1bHQgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiB0aGlzLnhmb3JtLnJlc3VsdCh2KTtcbn07XG5cblRha2VXaGlsZS5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uKHJlc3VsdCwgaW5wdXQpIHtcbiAgaWYodGhpcy5mKGlucHV0KSkge1xuICAgIHJldHVybiB0aGlzLnhmb3JtLnN0ZXAocmVzdWx0LCBpbnB1dCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBSZWR1Y2VkKHJlc3VsdCk7XG59O1xuXG5mdW5jdGlvbiB0YWtlV2hpbGUoY29sbCwgZiwgY3R4KSB7XG4gIGlmKGlzRnVuY3Rpb24oY29sbCkpIHsgY3R4ID0gZjsgZiA9IGNvbGw7IGNvbGwgPSBudWxsOyB9XG4gIGYgPSBib3VuZChmLCBjdHgpO1xuXG4gIGlmKGNvbGwpIHtcbiAgICByZXR1cm4gc2VxKGNvbGwsIHRha2VXaGlsZShmKSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oeGZvcm0pIHtcbiAgICByZXR1cm4gbmV3IFRha2VXaGlsZShmLCB4Zm9ybSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gVGFrZShuLCB4Zm9ybSkge1xuICB0aGlzLm4gPSBuO1xuICB0aGlzLmkgPSAwO1xuICB0aGlzLnhmb3JtID0geGZvcm07XG59XG5cblRha2UucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMueGZvcm0uaW5pdCgpO1xufTtcblxuVGFrZS5wcm90b3R5cGUucmVzdWx0ID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gdGhpcy54Zm9ybS5yZXN1bHQodik7XG59O1xuXG5UYWtlLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24ocmVzdWx0LCBpbnB1dCkge1xuICBpZiAodGhpcy5pIDwgdGhpcy5uKSB7XG4gICAgcmVzdWx0ID0gdGhpcy54Zm9ybS5zdGVwKHJlc3VsdCwgaW5wdXQpO1xuICAgIGlmKHRoaXMuaSArIDEgPj0gdGhpcy5uKSB7XG4gICAgICAvLyBGaW5pc2ggcmVkdWNpbmcgb24gdGhlIHNhbWUgc3RlcCBhcyB0aGUgZmluYWwgdmFsdWUuIFRPRE86XG4gICAgICAvLyBkb3VibGUtY2hlY2sgdGhhdCB0aGlzIGRvZXNuJ3QgYnJlYWsgYW55IHNlbWFudGljc1xuICAgICAgcmVzdWx0ID0gZW5zdXJlUmVkdWNlZChyZXN1bHQpO1xuICAgIH1cbiAgfVxuICB0aGlzLmkrKztcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmZ1bmN0aW9uIHRha2UoY29sbCwgbikge1xuICBpZihpc051bWJlcihjb2xsKSkgeyBuID0gY29sbDsgY29sbCA9IG51bGwgfVxuXG4gIGlmKGNvbGwpIHtcbiAgICByZXR1cm4gc2VxKGNvbGwsIHRha2UobikpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHhmb3JtKSB7XG4gICAgcmV0dXJuIG5ldyBUYWtlKG4sIHhmb3JtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBEcm9wKG4sIHhmb3JtKSB7XG4gIHRoaXMubiA9IG47XG4gIHRoaXMuaSA9IDA7XG4gIHRoaXMueGZvcm0gPSB4Zm9ybTtcbn1cblxuRHJvcC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy54Zm9ybS5pbml0KCk7XG59O1xuXG5Ecm9wLnByb3RvdHlwZS5yZXN1bHQgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiB0aGlzLnhmb3JtLnJlc3VsdCh2KTtcbn07XG5cbkRyb3AucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbihyZXN1bHQsIGlucHV0KSB7XG4gIGlmKHRoaXMuaSsrIDwgdGhpcy5uKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZXR1cm4gdGhpcy54Zm9ybS5zdGVwKHJlc3VsdCwgaW5wdXQpO1xufTtcblxuZnVuY3Rpb24gZHJvcChjb2xsLCBuKSB7XG4gIGlmKGlzTnVtYmVyKGNvbGwpKSB7IG4gPSBjb2xsOyBjb2xsID0gbnVsbCB9XG5cbiAgaWYoY29sbCkge1xuICAgIHJldHVybiBzZXEoY29sbCwgZHJvcChuKSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oeGZvcm0pIHtcbiAgICByZXR1cm4gbmV3IERyb3AobiwgeGZvcm0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIERyb3BXaGlsZShmLCB4Zm9ybSkge1xuICB0aGlzLnhmb3JtID0geGZvcm07XG4gIHRoaXMuZiA9IGY7XG4gIHRoaXMuZHJvcHBpbmcgPSB0cnVlO1xufVxuXG5Ecm9wV2hpbGUucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMueGZvcm0uaW5pdCgpO1xufTtcblxuRHJvcFdoaWxlLnByb3RvdHlwZS5yZXN1bHQgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiB0aGlzLnhmb3JtLnJlc3VsdCh2KTtcbn07XG5cbkRyb3BXaGlsZS5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uKHJlc3VsdCwgaW5wdXQpIHtcbiAgaWYodGhpcy5kcm9wcGluZykge1xuICAgIGlmKHRoaXMuZihpbnB1dCkpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5kcm9wcGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcy54Zm9ybS5zdGVwKHJlc3VsdCwgaW5wdXQpO1xufTtcblxuZnVuY3Rpb24gZHJvcFdoaWxlKGNvbGwsIGYsIGN0eCkge1xuICBpZihpc0Z1bmN0aW9uKGNvbGwpKSB7IGN0eCA9IGY7IGYgPSBjb2xsOyBjb2xsID0gbnVsbDsgfVxuICBmID0gYm91bmQoZiwgY3R4KTtcblxuICBpZihjb2xsKSB7XG4gICAgcmV0dXJuIHNlcShjb2xsLCBkcm9wV2hpbGUoZikpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHhmb3JtKSB7XG4gICAgcmV0dXJuIG5ldyBEcm9wV2hpbGUoZiwgeGZvcm0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIFBhcnRpdGlvbihuLCB4Zm9ybSkge1xuICB0aGlzLm4gPSBuO1xuICB0aGlzLmkgPSAwO1xuICB0aGlzLnhmb3JtID0geGZvcm07XG4gIHRoaXMucGFydCA9IG5ldyBBcnJheShuKTtcbn1cblxuUGFydGl0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnhmb3JtLmluaXQoKTtcbn07XG5cblBhcnRpdGlvbi5wcm90b3R5cGUucmVzdWx0ID0gZnVuY3Rpb24odikge1xuICBpZiAodGhpcy5pID4gMCkge1xuICAgIHJldHVybiBlbnN1cmVVbnJlZHVjZWQodGhpcy54Zm9ybS5zdGVwKHYsIHRoaXMucGFydC5zbGljZSgwLCB0aGlzLmkpKSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMueGZvcm0ucmVzdWx0KHYpO1xufTtcblxuUGFydGl0aW9uLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24ocmVzdWx0LCBpbnB1dCkge1xuICB0aGlzLnBhcnRbdGhpcy5pXSA9IGlucHV0O1xuICB0aGlzLmkgKz0gMTtcbiAgaWYgKHRoaXMuaSA9PT0gdGhpcy5uKSB7XG4gICAgdmFyIG91dCA9IHRoaXMucGFydC5zbGljZSgwLCB0aGlzLm4pO1xuICAgIHRoaXMucGFydCA9IG5ldyBBcnJheSh0aGlzLm4pO1xuICAgIHRoaXMuaSA9IDA7XG4gICAgcmV0dXJuIHRoaXMueGZvcm0uc3RlcChyZXN1bHQsIG91dCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmZ1bmN0aW9uIHBhcnRpdGlvbihjb2xsLCBuKSB7XG4gIGlmIChpc051bWJlcihjb2xsKSkge1xuICAgIG4gPSBjb2xsOyBjb2xsID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjb2xsKSB7XG4gICAgcmV0dXJuIHNlcShjb2xsLCBwYXJ0aXRpb24obikpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHhmb3JtKSB7XG4gICAgcmV0dXJuIG5ldyBQYXJ0aXRpb24obiwgeGZvcm0pO1xuICB9O1xufVxuXG52YXIgTk9USElORyA9IHt9O1xuXG5mdW5jdGlvbiBQYXJ0aXRpb25CeShmLCB4Zm9ybSkge1xuICAvLyBUT0RPOiB0YWtlIGFuIFwib3B0c1wiIG9iamVjdCB0aGF0IGFsbG93cyB0aGUgdXNlciB0byBzcGVjaWZ5XG4gIC8vIGVxdWFsaXR5XG4gIHRoaXMuZiA9IGY7XG4gIHRoaXMueGZvcm0gPSB4Zm9ybTtcbiAgdGhpcy5wYXJ0ID0gW107XG4gIHRoaXMubGFzdCA9IE5PVEhJTkc7XG59XG5cblBhcnRpdGlvbkJ5LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnhmb3JtLmluaXQoKTtcbn07XG5cblBhcnRpdGlvbkJ5LnByb3RvdHlwZS5yZXN1bHQgPSBmdW5jdGlvbih2KSB7XG4gIHZhciBsID0gdGhpcy5wYXJ0Lmxlbmd0aDtcbiAgaWYgKGwgPiAwKSB7XG4gICAgcmV0dXJuIGVuc3VyZVVucmVkdWNlZCh0aGlzLnhmb3JtLnN0ZXAodiwgdGhpcy5wYXJ0LnNsaWNlKDAsIGwpKSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMueGZvcm0ucmVzdWx0KHYpO1xufTtcblxuUGFydGl0aW9uQnkucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbihyZXN1bHQsIGlucHV0KSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5mKGlucHV0KTtcbiAgaWYgKGN1cnJlbnQgPT09IHRoaXMubGFzdCB8fCB0aGlzLmxhc3QgPT09IE5PVEhJTkcpIHtcbiAgICB0aGlzLnBhcnQucHVzaChpbnB1dCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gdGhpcy54Zm9ybS5zdGVwKHJlc3VsdCwgdGhpcy5wYXJ0KTtcbiAgICB0aGlzLnBhcnQgPSBbaW5wdXRdO1xuICB9XG4gIHRoaXMubGFzdCA9IGN1cnJlbnQ7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiBwYXJ0aXRpb25CeShjb2xsLCBmLCBjdHgpIHtcbiAgaWYgKGlzRnVuY3Rpb24oY29sbCkpIHsgY3R4ID0gZjsgZiA9IGNvbGw7IGNvbGwgPSBudWxsOyB9XG4gIGYgPSBib3VuZChmLCBjdHgpO1xuXG4gIGlmIChjb2xsKSB7XG4gICAgcmV0dXJuIHNlcShjb2xsLCBwYXJ0aXRpb25CeShmKSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oeGZvcm0pIHtcbiAgICByZXR1cm4gbmV3IFBhcnRpdGlvbkJ5KGYsIHhmb3JtKTtcbiAgfTtcbn1cblxuLy8gcHVyZSB0cmFuc2R1Y2VycyAoY2Fubm90IHRha2UgY29sbGVjdGlvbnMpXG5cbmZ1bmN0aW9uIENhdCh4Zm9ybSkge1xuICB0aGlzLnhmb3JtID0geGZvcm07XG59XG5cbkNhdC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy54Zm9ybS5pbml0KCk7XG59O1xuXG5DYXQucHJvdG90eXBlLnJlc3VsdCA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIHRoaXMueGZvcm0ucmVzdWx0KHYpO1xufTtcblxuQ2F0LnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24ocmVzdWx0LCBpbnB1dCkge1xuICB2YXIgeGZvcm0gPSB0aGlzLnhmb3JtO1xuICB2YXIgbmV3eGZvcm0gPSB7XG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4geGZvcm0uaW5pdCgpO1xuICAgIH0sXG4gICAgcmVzdWx0OiBmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gdjtcbiAgICB9LFxuICAgIHN0ZXA6IGZ1bmN0aW9uKHJlc3VsdCwgaW5wdXQpIHtcbiAgICAgIHZhciB2YWwgPSB4Zm9ybS5zdGVwKHJlc3VsdCwgaW5wdXQpO1xuICAgICAgcmV0dXJuIGlzUmVkdWNlZCh2YWwpID8gZGVyZWYodmFsKSA6IHZhbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVkdWNlKGlucHV0LCBuZXd4Zm9ybSwgcmVzdWx0KTtcbn07XG5cbmZ1bmN0aW9uIGNhdCh4Zm9ybSkge1xuICByZXR1cm4gbmV3IENhdCh4Zm9ybSk7XG59XG5cbmZ1bmN0aW9uIG1hcGNhdChmLCBjdHgpIHtcbiAgZiA9IGJvdW5kKGYsIGN0eCk7XG4gIHJldHVybiBjb21wb3NlKG1hcChmKSwgY2F0KTtcbn1cblxuLy8gY29sbGVjdGlvbiBoZWxwZXJzXG5cbmZ1bmN0aW9uIHB1c2goYXJyLCB4KSB7XG4gIGFyci5wdXNoKHgpO1xuICByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBtZXJnZShvYmosIHgpIHtcbiAgaWYoaXNBcnJheSh4KSAmJiB4Lmxlbmd0aCA9PT0gMikge1xuICAgIG9ialt4WzBdXSA9IHhbMV07XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh4KTtcbiAgICB2YXIgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgZm9yKHZhciBpPTA7IGk8bGVuOyBpKyspIHtcbiAgICAgIG9ialtrZXlzW2ldXSA9IHhba2V5c1tpXV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbnZhciBhcnJheVJlZHVjZXIgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBbXTtcbiAgfSxcbiAgcmVzdWx0OiBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIHY7XG4gIH0sXG4gIHN0ZXA6IHB1c2hcbn1cblxudmFyIG9ialJlZHVjZXIgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7fTtcbiAgfSxcbiAgcmVzdWx0OiBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIHY7XG4gIH0sXG4gIHN0ZXA6IG1lcmdlXG59O1xuXG5mdW5jdGlvbiBnZXRSZWR1Y2VyKGNvbGwpIHtcbiAgaWYoaXNBcnJheShjb2xsKSkge1xuICAgIHJldHVybiBhcnJheVJlZHVjZXI7XG4gIH1cbiAgZWxzZSBpZihpc09iamVjdChjb2xsKSkge1xuICAgIHJldHVybiBvYmpSZWR1Y2VyO1xuICB9XG4gIGVsc2UgaWYoZnVsZmlsbHNQcm90b2NvbChjb2xsLCAndHJhbnNmb3JtZXInKSkge1xuICAgIHJldHVybiBnZXRQcm90b2NvbFByb3BlcnR5KGNvbGwsICd0cmFuc2Zvcm1lcicpO1xuICB9XG4gIHRocm93UHJvdG9jb2xFcnJvcignZ2V0UmVkdWNlcicsIGNvbGwpO1xufVxuXG4vLyBidWlsZGluZyBuZXcgY29sbGVjdGlvbnNcblxuZnVuY3Rpb24gdG9BcnJheShjb2xsLCB4Zm9ybSkge1xuICBpZigheGZvcm0pIHtcbiAgICByZXR1cm4gcmVkdWNlKGNvbGwsIGFycmF5UmVkdWNlciwgW10pO1xuICB9XG4gIHJldHVybiB0cmFuc2R1Y2UoY29sbCwgeGZvcm0sIGFycmF5UmVkdWNlciwgW10pO1xufVxuXG5mdW5jdGlvbiB0b09iaihjb2xsLCB4Zm9ybSkge1xuICBpZigheGZvcm0pIHtcbiAgICByZXR1cm4gcmVkdWNlKGNvbGwsIG9ialJlZHVjZXIsIHt9KTtcbiAgfVxuICByZXR1cm4gdHJhbnNkdWNlKGNvbGwsIHhmb3JtLCBvYmpSZWR1Y2VyLCB7fSk7XG59XG5cbmZ1bmN0aW9uIHRvSXRlcihjb2xsLCB4Zm9ybSkge1xuICBpZigheGZvcm0pIHtcbiAgICByZXR1cm4gaXRlcmF0b3IoY29sbCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBMYXp5VHJhbnNmb3JtZXIoeGZvcm0sIGNvbGwpO1xufVxuXG5mdW5jdGlvbiBzZXEoY29sbCwgeGZvcm0pIHtcbiAgaWYoaXNBcnJheShjb2xsKSkge1xuICAgIHJldHVybiB0cmFuc2R1Y2UoY29sbCwgeGZvcm0sIGFycmF5UmVkdWNlciwgW10pO1xuICB9XG4gIGVsc2UgaWYoaXNPYmplY3QoY29sbCkpIHtcbiAgICByZXR1cm4gdHJhbnNkdWNlKGNvbGwsIHhmb3JtLCBvYmpSZWR1Y2VyLCB7fSk7XG4gIH1cbiAgZWxzZSBpZihmdWxmaWxsc1Byb3RvY29sKGNvbGwsICd0cmFuc2Zvcm1lcicpKSB7XG4gICAgdmFyIHRyYW5zZm9ybWVyID0gZ2V0UHJvdG9jb2xQcm9wZXJ0eShjb2xsLCAndHJhbnNmb3JtZXInKTtcbiAgICByZXR1cm4gdHJhbnNkdWNlKGNvbGwsIHhmb3JtLCB0cmFuc2Zvcm1lciwgdHJhbnNmb3JtZXIuaW5pdCgpKTtcbiAgfVxuICBlbHNlIGlmKGZ1bGZpbGxzUHJvdG9jb2woY29sbCwgJ2l0ZXJhdG9yJykpIHtcbiAgICByZXR1cm4gbmV3IExhenlUcmFuc2Zvcm1lcih4Zm9ybSwgY29sbCk7XG4gIH1cbiAgdGhyb3dQcm90b2NvbEVycm9yKCdzZXF1ZW5jZScsIGNvbGwpO1xufVxuXG5mdW5jdGlvbiBpbnRvKHRvLCB4Zm9ybSwgZnJvbSkge1xuICBpZihpc0FycmF5KHRvKSkge1xuICAgIHJldHVybiB0cmFuc2R1Y2UoZnJvbSwgeGZvcm0sIGFycmF5UmVkdWNlciwgdG8pO1xuICB9XG4gIGVsc2UgaWYoaXNPYmplY3QodG8pKSB7XG4gICAgcmV0dXJuIHRyYW5zZHVjZShmcm9tLCB4Zm9ybSwgb2JqUmVkdWNlciwgdG8pO1xuICB9XG4gIGVsc2UgaWYoZnVsZmlsbHNQcm90b2NvbCh0bywgJ3RyYW5zZm9ybWVyJykpIHtcbiAgICByZXR1cm4gdHJhbnNkdWNlKGZyb20sXG4gICAgICAgICAgICAgICAgICAgICB4Zm9ybSxcbiAgICAgICAgICAgICAgICAgICAgIGdldFByb3RvY29sUHJvcGVydHkodG8sICd0cmFuc2Zvcm1lcicpLFxuICAgICAgICAgICAgICAgICAgICAgdG8pO1xuICB9XG4gIHRocm93UHJvdG9jb2xFcnJvcignaW50bycsIHRvKTtcbn1cblxuLy8gbGF6aW5lc3NcblxudmFyIHN0ZXBwZXIgPSB7XG4gIHJlc3VsdDogZnVuY3Rpb24odikge1xuICAgIHJldHVybiBpc1JlZHVjZWQodikgPyBkZXJlZih2KSA6IHY7XG4gIH0sXG4gIHN0ZXA6IGZ1bmN0aW9uKGx0LCB4KSB7XG4gICAgbHQuaXRlbXMucHVzaCh4KTtcbiAgICByZXR1cm4gbHQucmVzdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBTdGVwcGVyKHhmb3JtLCBpdGVyKSB7XG4gIHRoaXMueGZvcm0gPSB4Zm9ybShzdGVwcGVyKTtcbiAgdGhpcy5pdGVyID0gaXRlcjtcbn1cblxuU3RlcHBlci5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uKGx0KSB7XG4gIHZhciBsZW4gPSBsdC5pdGVtcy5sZW5ndGg7XG4gIHdoaWxlKGx0Lml0ZW1zLmxlbmd0aCA9PT0gbGVuKSB7XG4gICAgdmFyIG4gPSB0aGlzLml0ZXIubmV4dCgpO1xuICAgIGlmKG4uZG9uZSB8fCBpc1JlZHVjZWQobi52YWx1ZSkpIHtcbiAgICAgIC8vIGZpbmFsaXplXG4gICAgICB0aGlzLnhmb3JtLnJlc3VsdCh0aGlzKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIHN0ZXBcbiAgICB0aGlzLnhmb3JtLnN0ZXAobHQsIG4udmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIExhenlUcmFuc2Zvcm1lcih4Zm9ybSwgY29sbCkge1xuICB0aGlzLml0ZXIgPSBpdGVyYXRvcihjb2xsKTtcbiAgdGhpcy5pdGVtcyA9IFtdO1xuICB0aGlzLnN0ZXBwZXIgPSBuZXcgU3RlcHBlcih4Zm9ybSwgaXRlcmF0b3IoY29sbCkpO1xufVxuXG5MYXp5VHJhbnNmb3JtZXIucHJvdG90eXBlW3Byb3RvY29scy5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbkxhenlUcmFuc2Zvcm1lci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnN0ZXAoKTtcblxuICBpZih0aGlzLml0ZW1zLmxlbmd0aCkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogdGhpcy5pdGVtcy5wb3AoKSxcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiB7IGRvbmU6IHRydWUgfTtcbiAgfVxufTtcblxuTGF6eVRyYW5zZm9ybWVyLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24oKSB7XG4gIGlmKCF0aGlzLml0ZW1zLmxlbmd0aCkge1xuICAgIHRoaXMuc3RlcHBlci5zdGVwKHRoaXMpO1xuICB9XG59XG5cbi8vIHV0aWxcblxuZnVuY3Rpb24gcmFuZ2Uobikge1xuICB2YXIgYXJyID0gbmV3IEFycmF5KG4pO1xuICBmb3IodmFyIGk9MDsgaTxhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBhcnJbaV0gPSBpO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJlZHVjZTogcmVkdWNlLFxuICB0cmFuc2Zvcm1lcjogdHJhbnNmb3JtZXIsXG4gIFJlZHVjZWQ6IFJlZHVjZWQsXG4gIGl0ZXJhdG9yOiBpdGVyYXRvcixcbiAgcHVzaDogcHVzaCxcbiAgbWVyZ2U6IG1lcmdlLFxuICB0cmFuc2R1Y2U6IHRyYW5zZHVjZSxcbiAgc2VxOiBzZXEsXG4gIHRvQXJyYXk6IHRvQXJyYXksXG4gIHRvT2JqOiB0b09iaixcbiAgdG9JdGVyOiB0b0l0ZXIsXG4gIGludG86IGludG8sXG4gIGNvbXBvc2U6IGNvbXBvc2UsXG4gIG1hcDogbWFwLFxuICBmaWx0ZXI6IGZpbHRlcixcbiAgcmVtb3ZlOiByZW1vdmUsXG4gIGNhdDogY2F0LFxuICBtYXBjYXQ6IG1hcGNhdCxcbiAga2VlcDoga2VlcCxcbiAgZGVkdXBlOiBkZWR1cGUsXG4gIHRha2U6IHRha2UsXG4gIHRha2VXaGlsZTogdGFrZVdoaWxlLFxuICBkcm9wOiBkcm9wLFxuICBkcm9wV2hpbGU6IGRyb3BXaGlsZSxcbiAgcGFydGl0aW9uOiBwYXJ0aXRpb24sXG4gIHBhcnRpdGlvbkJ5OiBwYXJ0aXRpb25CeSxcbiAgcmFuZ2U6IHJhbmdlLFxuXG4gIHByb3RvY29sczogcHJvdG9jb2xzLFxuICBMYXp5VHJhbnNmb3JtZXI6IExhenlUcmFuc2Zvcm1lclxufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3RyYW5zZHVjZXJzLmpzL3RyYW5zZHVjZXJzLmpzXG4gKiogbW9kdWxlIGlkID0gMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }
/******/ ]);